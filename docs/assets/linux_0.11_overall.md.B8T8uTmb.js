import{_ as l,c as i,o as e,ag as r}from"./chunks/framework.BmLMQRXF.js";const c=JSON.parse('{"title":"Linux 0.11 源码阅读","description":"","frontmatter":{},"headers":[],"relativePath":"linux/0.11/overall.md","filePath":"linux/0.11/overall.md"}'),o={name:"linux/0.11/overall.md"};function t(n,a,h,u,d,s){return e(),i("div",null,a[0]||(a[0]=[r('<h1 id="linux-0-11-源码阅读" tabindex="-1">Linux 0.11 源码阅读 <a class="header-anchor" href="#linux-0-11-源码阅读" aria-label="Permalink to &quot;Linux 0.11 源码阅读&quot;">​</a></h1><h2 id="总述" tabindex="-1">总述 <a class="header-anchor" href="#总述" aria-label="Permalink to &quot;总述&quot;">​</a></h2><p>这部分源码总体上完成了以下几个部分的内容:</p><ol><li>硬件方面 <ul><li>Intel 80386 芯片中断</li><li>块设备驱动 (软盘,硬盘)</li><li>字符设备驱动 (键盘,鼠标)</li><li>CMOS 读时钟</li></ul></li><li>内核方面 <ul><li>段表</li><li>页表</li><li>进程管理</li><li>内存管理</li><li>文件系统</li><li>系统调用</li></ul></li><li>软件方面 <ul><li>shell</li></ul></li></ol><p>源码的阅读需要额外了解一些其他内容的知识,会在以后逐渐补充, 例如在硬件方面,需要了解 Intel 芯片的具体机制和系统中断指令, 此外在文件系统和驱动方面还需要上手硬件的编程,这部分内容难以在短时间内掌握.</p><p>对于内核方面的东西,我们可以清晰地看到其实现.在操作系统的这一层,各种伪装都已被解开, 没有任何封装. 此部分应该熟悉汇编代码和 asm 嵌入 C 的写法. 在了解操作系统原理的基础上, 应该关注内核的整体设计,尤其关注内存的分配和管理,应该做到心中明了每一条指令所调用的系统调用, 以及是否缺页.</p><p>软件方面主要为 shell 程序,此部分代码不在内核内,可以参考 bash 等的实现.</p><p>Linux 源码是我第一个阅读的源码工程,应该先掌握大体框架,即我已经知道这部分代码的功能, 在深入考虑每一条语句的意义,最后要对其代码做出修正,指出其不足.</p><h2 id="各模块总述" tabindex="-1">各模块总述 <a class="header-anchor" href="#各模块总述" aria-label="Permalink to &quot;各模块总述&quot;">​</a></h2><h3 id="内核引导" tabindex="-1">内核引导 <a class="header-anchor" href="#内核引导" aria-label="Permalink to &quot;内核引导&quot;">​</a></h3><p>包括三个文件,主要将操作系统的代码加载到内存,设置好基本的段表,页表和系统中断, 从实模式进入保护模式,并调用 main 函数进行初始化.</p><h3 id="内核初始化" tabindex="-1">内核初始化 <a class="header-anchor" href="#内核初始化" aria-label="Permalink to &quot;内核初始化&quot;">​</a></h3><p>先调用进行各模块的初始化, 然后进程 0 fork 进程 1, 然后进程 1 加载根文件系统,此时可以加载并运行磁盘上的其他程序, 之后通过系统调用 execve 函数加载 shell 程序进入命令行交互.</p><h3 id="io-块设备" tabindex="-1">IO 块设备 <a class="header-anchor" href="#io-块设备" aria-label="Permalink to &quot;IO 块设备&quot;">​</a></h3><p>软盘</p><h3 id="io-字符设备" tabindex="-1">IO 字符设备 <a class="header-anchor" href="#io-字符设备" aria-label="Permalink to &quot;IO 字符设备&quot;">​</a></h3><p>鼠标和键盘</p><h3 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to &quot;进程&quot;">​</a></h3><p>完全由在 GDT 中的 TSS 描述</p><h3 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h3><ul><li>段表</li></ul><p>GDT 为全局描述符表,保存每个进程的 LDT 和 TSS</p><p>LDT 为局部描述符表,保存每个进程的段表</p><ul><li>页表</li></ul><p>采用二级页表</p><h3 id="系统调用" tabindex="-1">系统调用 <a class="header-anchor" href="#系统调用" aria-label="Permalink to &quot;系统调用&quot;">​</a></h3><h3 id="文件系统" tabindex="-1">文件系统 <a class="header-anchor" href="#文件系统" aria-label="Permalink to &quot;文件系统&quot;">​</a></h3><p>ext2 文件系统</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ol><li>书籍 <ul><li>Linux 源码趣读 闪客</li><li>Linux 内核完全注释 赵炯</li><li>深入理解Linux进程与内存 张彦飞</li></ul></li></ol>',30)]))}const x=l(o,[["render",t]]);export{c as __pageData,x as default};
